<article><style>article{
    max-width: 800px;
    font-size: 12pt;
    font-family: sans-serif;
    margin: 3em auto;
}

article h1{
    text-align: center;
    font-size: 2em;
}

article img{
    margin: 0 auto;
    max-width: 100%;
}

article blockquote{
    border-left: 0.2em solid gray;
    margin-left: 1em;
    padding-left: 1em;
}

article figcaption{
    padding: 0.2em 1em;
    background: #E0E0E0;
}

article code{
    background: #F0F0F0;
    padding: 0 0.1em;
}

article .code-block{
    padding: 0.1em 0.5em;
    overflow-x: auto;
}</style><h1 id="debugging">Debugging</h1><p>Trial includes a variety of tools to aid in the inevitable debugging process.</p><h2 id="logging">Logging</h2><p>Trial relies on the <a class="external-link" href="https://shinmera.github.io/verbose">Verbose</a> logger framework to print various status messages to its log. You can, of course, make use of all of Verbose's features yourself as well. You should add a local nickname for <code>org.shirakumo.verbose</code> (as <code>v</code>) to your package definitions for that.</p><p>When deployed, Trial will also automatically capture Verbose's log to a logfile that can be used for debugging crashes and other issues.</p><p>Trial also offers a number of useful shorthand macros:</p><ul><li><p><code>with-error-logging</code><br>Will log any unhandled error that is signalled within the body.</p></li><li><p><code>with-ignored-errors-on-release</code><br>Does the same as <code>with-error-logging</code> but ignoring the error in release mode and propagating it to the debugger with a <code>continue</code> restart in development mode.</p></li><li><p><code>with-timing-report</code><br>Logs a report on the time taken to execute the body.</p></li></ul><h2 id="watches">Watches</h2><p>You can add a watchpoint for the result of a function with the <code>observe</code> function, or of an expression with the <code>observe!</code> macro. To remove the watchpoint again, you can use <code>stop-observing</code>.</p><p>In order for the watches to show up, you must have a <code>display-controller</code> in your scene. Typically you'll want to do this by using <code>(enter (make-instance 'display-controller) scene)</code> in your <code>setup-scene</code>.</p><p>You can also use an <code>fps-counter</code> instance to only observe the frame count. The <code>fps-counter</code> in particular is written to be as low latency as possible, and should have almost zero overhead.</p><h2 id="drawing">Drawing</h2><p>In order to debug visual information, you can use the following functions:</p><ul><li><p><code>debug-point</code><br>Draws a point at the specified coordinate.</p></li><li><p><code>debug-line</code><br>Draws a line between the specified points.</p></li><li><p><code>debug-text</code><br>Shows the text at the specified point. The text can only contain ASCII characters.</p></li><li><p><code>debug-triangles</code><br>Draw a set of triangles as a line mesh.</p></li><li><p><code>debug-vertex-array</code><br>Draw a vertex array as a line mesh. This should work regardless of primitive shape used.</p></li><li><p><code>debug-clear</code><br>Clear all debug draws.</p></li><li><p><code>debug-draw</code><br>Generic version that dispatches to the above depending on the argument.</p></li></ul><p>All of these are copying, meaning they won't update if their arguments are modified and they'll stick around until cleared away. All of the functions also accept the following arguments:</p><ul><li><p><code>:color</code><br>The color of the lines or point.</p></li><li><p><code>:debug-draw</code><br>The <code>debug-draw</code> instance used to draw the elements. Defaults to using an entity named <code>debug-draw</code> and will create one if it doesn't exist yet.</p></li><li><p><code>:update</code><br>Whether the data should be uploaded to the GPU immediately. You may want to set this to NIL if you intend on drawing a large batch of debug info.</p></li></ul><p>Note that all drawing calls are synchronised to the render thread. Meaning that if the call occurs outside of the render thread, it is scheduled asynchronously to run on it.</p><h2 id="renderdoc">Renderdoc</h2><p>Special mention should be made of the <a class="external-link" href="https://renderdoc.org">Renderdoc</a> tool. While Trial allows redefinition of shaders at runtime, sometimes being able to capture the entire pipeline state and inspect it can be invaluable to figure out weird graphical issues. Renderdoc is ideal for this situation and works fine with Trial, as long as the underlying lisp process is called via Renderdoc.</p><p>To do so, create a small script like so:</p><code style="display:block" class="code-block" data-language="common lisp"><pre>(ql:quickload :swank)
(swank:create-server)
(ql:quickload :my-project)
(my-project::launch)</pre></code><p>Then you can configure your implementation as a launch option in Rendedoc:</p><ul><li><p><code>Executable Path</code> Eg: <code>/usr/bin/sbcl</code></p></li><li><p><code>Command-line Arguments</code> Eg: <code>--load /tmp/renderdoc.lisp</code></p></li></ul><p>Launching it like that should allow you to connect via Slime on port 4005, and capture snapshots of the running process via Renderdoc.</p></article>