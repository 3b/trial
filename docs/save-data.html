<!DOCTYPE html><html><head><title>Trial / Save Data</title><meta property="og:image" content="https://repository-images.githubusercontent.com/54314855/81c55af6-b2c4-45f0-b66d-f29fdd37be7f"><meta property="og:image:alt" content="Most games keep some amount of state between play sessions to track the player's progress. This is separate from the settings. A lot of the time the amount of data to store and the format to best store that in is very heavily dependent on the type of game being made. Sometimes it's a single level number. Sometimes it needs to be complex data structures to store items, placement, story progress etc."><meta property="og:type" content="object"><meta property="og:title" content="Trial / Save Data"><meta property="og:url" content="https://shirakumo.org/docs/trial/save-data.mess.html"><meta property="og:description" content="Most games keep some amount of state between play sessions to track the player's progress. This is separate from the settings. A lot of the time the amount of data to store and the format to best store that in is very heavily dependent on the type of game being made. Sometimes it's a single level number. Sometimes it needs to be complex data structures to store items, placement, story progress etc."></head><body><article><a class="index" href="index.html">Index</a><style>article{max-width:800px;font-size:12pt;font-family:sans-serif;margin:0 auto 3em auto;}article h1{text-align:center;font-size:2em;}article img{margin:0 auto;max-width:100%;}article blockquote{border-left:0.2em solid gray;margin-left:1em;padding-left:1em;}article figcaption{padding:0.2em 1em;background:#E0E0E0;}article code{background:#F0F0F0;padding:0 0.1em;}article .code-block{padding:0.1em 0.5em;overflow-x:auto;}article a.index{display:block;text-decoration:none;text-align:center;font-size:1.1em;background:#151515;border:2px solid #151515;color:#FEFEFE;}article a.index:hover{background:#FEFEFE;color:#151515;}</style><h1 id="save data">Save Data</h1><p>Most games keep some amount of state between play sessions to track the player's progress. This is separate from the <a class="external-link" href="settings.html">settings</a>. A lot of the time the amount of data to store and the format to best store that in is very heavily dependent on the type of game being made. Sometimes it's a single level number. Sometimes it needs to be complex data structures to store items, placement, story progress etc.</p><p>As such, Trial's save-data support is relatively minimal. It provides a general way to preserve and restore data inside a <a class="external-link" href="https://shinmera.github.io/depot">depot</a>, as well as a generic <code>save-file</code> data structure that tracks the most common information, such as who saved in what slot, when, where, how long they've played, and an optional preview image to display in a menu.</p><p>In order to actually define what data to save and how, you should first create a new <code>save-file</code> type. This will also track the version of the save file, ensuring that you can migrate save files over time.</p><code style="display:block" class="code-block" data-language="common lisp"><pre>(defclass my-save-file (save-file) ())
(defmethod version ((file my-save-file)) 1)
(defmethod save-version-type ((version (eql 1))) 'my-save-file)
(defmethod save-version-type ((default (eql T))) 'my-save-file)</pre></code><p>With this we have a new save-file type and a way to decode its version. We've also set it as the default version to use when constructing new saves. Now for the decoding.</p><code style="display:block" class="code-block" data-language="common lisp"><pre>(defmethod load-save-data ((file my-save-file) (depot depot:depot))
  ...)

(defmethod store-save-data ((file my-save-file) (depot depot:depot) &amp;key)
  ...)</pre></code><p>From here what you do and how you store things is entirely up to you. Please refer to the <a class="external-link" href="https://shinmera.github.io/depot">depot API</a> for how to access files and data inside a depot. The only restriction is that you do not touch the depot entries called <code>manifest</code> or <code>preview.png</code>, which are maintained by the save-file system for you.</p><p>As mentioned, often you won't need to store terribly much or complex data. In that case, <code>define-simple-save-file</code> can be used:</p><code style="display:block" class="code-block" data-language="common lisp"><pre>(define-simple-save-file 1 :latest
  (:decode (depot score)
    (setf +score+ score))
  (:encode (depot)
    (list +score+)))</pre></code><p>This will simply store the hypothetical <code>+score+</code> variable and set it to the loaded value. <code>:decode</code> expects a destructuring-lambda-list, which <code>:encode</code> should return in the same form, so you can store any Lisp value that is readable. This should suffice for a majority of cases. However, since you still also have access to the <code>depot</code> you can also store auxiliary entries or do whatever else necessary.</p><p>In order to list the available save files, simply use <code>list-save-files</code>. This will perform a &quot;minimal load&quot; of the save file, only reading out its metadata without actually decoding it. You can then call <code>load-save-data</code> to actually restore its state. Similarly, you can invoke <code>store-save-data</code> to store the state. The actual save data is stored where suitable depending on the platform Trial is running under. On PCs this is as a file within the <code>config-directory</code>.</p><p>Every save file has a unique <code>id</code> that distinguishes it from every other save file. In the storage, each save file however is only distinguished by its <code>slot</code>. Meaning that a save file with the same <code>slot</code> as another will replace it when stored, but will have a different <code>id</code>.</p><p>Setting the save file's <code>image</code> to <code>T</code> or some other parameter suitable for <code>save-image</code> prior to calling <code>store-save-data</code> will generate and store that as a preview image, with <code>T</code> simply referring to the current scene.</p><p>The save file's <code>save-time</code> is automatically updated when stored, but the <code>play-duration</code> must be updated by you, in order to accurately track how much time the player has spent on the save file.</p><p>Finally each save file also keeps a <code>username</code> which can be used to let the user identify the save file for themselves in some way. It defaults to the system's <code>username</code>.</p><p>If you want to control the file's metadata precisely, you can simply create an instance of your desired version's respective type. You can also pass a slot name directly to <code>load-save-data</code> or <code>store-save-data</code>; in the latter case a new save-file instance is created and automatically, relying on the default <code>save-version-type</code>.</p></article></body></html><link rel="stylesheet" href="highlight-lisp.css"><script type="text/javascript" src="highlight-lisp.js"></script><script type="text/javascript">[...document.querySelectorAll('[data-language="common lisp"] pre')].map(HighlightLisp.highlight_element);</script>