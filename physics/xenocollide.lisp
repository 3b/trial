;;; This implementation is based on the original Xenocollide code by Gary Snethen available at 
;;;   https://github.com/erwincoumans/xenocollide
;;;

(defpackage #:org.shirakumo.fraf.trial.mpr
  (:use #:cl #:org.shirakumo.fraf.math)
  (:export
   #:detect-hits
   #:support-function))

(in-package #:org.shirakumo.fraf.trial.mpr)

(defconstant COLLIDE-EPS 1f-3)

(defun transform-support-vert (p q tt n)
  (let* ((local-normal (q* (qinv q) n))
         (local-support (vec3)))
    (org.shirakumo.fraf.trial.gjk::support-function p local-normal local-support)
    (nv+ (nq* q local-support) tt)))

(defun %mpr (p1 q1 t1 p2 q2 t2 return-normal point1 point2)
  (flet ((finish (value)
           (return-from %mpr value)))
    (let* ((v01 (nv+ (q* q1 (trial:location p1)) t1))
           (v02 (nv+ (q* q2 (trial:location p2)) t2))
           (v0 (v- v02 v01)))
      (when (v= 0 v0)
        (vsetf v0 0.00001 0 0))
      (let* ((n (v- v0))
             (v11 (transform-support-vert p1 q1 t1 (v- n)))
             (v12 (transform-support-vert p2 q2 t2 n))
             (v1 (v- v12 v11)))
        (when (<= (v. v1 n) 0)
          (v<- return-normal n)
          (finish NIL))
        (!vc n v1 v0)
        (when (v= 0 n)
          (!v- n v1 v0)
          (nvunit n)
          (v<- return-normal n)
          (v<- point1 v11)
          (v<- point2 v12)
          (finish T))
        (let* ((v21 (transform-support-vert p1 q1 t1 (v- n)))
               (v22 (transform-support-vert p2 q2 t2 n))
               (v2 (v- v22 v21)))
          (when (<= (v. v2 n) 0)
            (v<- return-normal n)
            (finish NIL))
          (!vc n (v- v1 v0) (v- v2 v0))
          (let ((dist (v. n v0)))
            (when (< 0 dist)
              (rotatef v1 v2)
              (rotatef v11 v21)
              (rotatef v12 v22)
              (nv- n)))

          (loop for hit = NIL
                for phase2 = 0
                for v31 = (transform-support-vert p1 q1 t1 (v- n))
                for v32 = (transform-support-vert p2 q2 t2 n)
                for v3 = (v- v32 v31)
                do (when (<= (v. v3 n) 0)
                     (v<- return-normal n)
                     (finish NIL))
                   (cond ((< (v. (vc v1 v3) v0) 0)
                          (v<- v2 v3)
                          (v<- v21 v31)
                          (v<- v22 v32)
                          (!vc n (v- v1 v0) (v- v3 v0)))
                         ((< (v. (vc v3 v2) v0) 0)
                          (v<- v1 v3)
                          (v<- v11 v31)
                          (v<- v12 v32)
                          (!vc n (v- v3 v0) (v- v2 v0)))
                         (T
                          (loop (incf phase2)
                                ;; (when (< 1 phase2)
                                ;;   )
                                (!vc n (v- v2 v1) (v- v3 v1))
                                (assert (not (v= 0 n)))
                                (nvunit n)
                                (let ((d (v. n v1)))
                                  (when (and (not hit) (<= 0 d))
                                    (v<- return-normal n)
                                    (let* ((b0 (v. (vc v1 v2) v3))
                                           (b1 (v. (vc v3 v2) v0))
                                           (b2 (v. (vc v0 v1) v3))
                                           (b3 (v. (vc v2 v1) v0))
                                           (sum (+ b0 b1 b2 b3)))
                                      (when (<= sum 0)
                                        (setf b0 0
                                              b1 (v. (vc v2 v3) n)
                                              b2 (v. (vc v3 v1) n)
                                              b3 (v. (vc v1 v2) n)
                                              sum (+ b1 b2 b3)))
                                      (!v* point1 v01 b0)
                                      (nv+* point1 v11 b1)
                                      (nv+* point1 v21 b2)
                                      (nv+* point1 v31 b3)
                                      (!v* point2 v02 b0)
                                      (nv+* point2 v12 b1)
                                      (nv+* point2 v22 b2)
                                      (nv+* point2 v32 b3)
                                      (setf hit T))))
                                (let* ((v41 (transform-support-vert p1 q1 t1 (v- n)))
                                       (v42 (transform-support-vert p2 q2 t2 n))
                                       (v4 (v- v42 v41))
                                       (delta (v. (v- v4 v3) n))
                                       (separation (- (v. v4 n))))
                                  (when (or (<= delta COLLIDE-EPS) (<= 0 separation))
                                    (v<- return-normal n)
                                    (finish hit))
                                  (let* ((d1 (v. (vc v4 v1) v0))
                                         (d2 (v. (vc v4 v2) v0))
                                         (d3 (v. (vc v4 v3) v0)))
                                    (if (< d1 0)
                                        (cond ((< d2 0)
                                               (v<- v1 v4)
                                               (v<- v11 v41)
                                               (v<- v12 v42))
                                              (T
                                               (v<- v3 v4)
                                               (v<- v31 v41)
                                               (v<- v32 v42)))
                                        (cond ((< d3 0)
                                               (v<- v2 v4)
                                               (v<- v21 v41)
                                               (v<- v22 v42))
                                              (T
                                               (v<- v1 v4)
                                               (v<- v11 v41)
                                               (v<- v12 v42)))))))))))))))

(defun detect-hits (a b hits start end)
  (declare (type trial:primitive a b))
  (declare (type (unsigned-byte 32) start end))
  (declare (type simple-vector hits))
  (declare (optimize speed))
  (when (<= end start)
    (return-from detect-hits start))
  (let* ((hit (aref hits start))
         (normal (trial:hit-normal hit))
         (ap (trial:hit-location hit))
         (bp (vec3)))
    (cond ((%mpr a 
                  (qfrom-mat (trial:primitive-transform a))
                  (trial:location a)
                  b
                  (qfrom-mat (trial:primitive-transform b))
                  (trial:location b)
                  normal
                  ap
                  bp)
           (setf (trial:hit-depth hit) (vdistance ap bp))
           (trial:finish-hit hit a b)
           (1+ start))
          (T
           start))))
