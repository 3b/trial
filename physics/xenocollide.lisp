;;; This implementation is based on the original Xenocollide code by Gary Snethen available at 
;;;   https://github.com/erwincoumans/xenocollide
;;;

(defpackage #:org.shirakumo.fraf.trial.mpr
  (:use #:cl #:org.shirakumo.fraf.math)
  (:export
   #:detect-hits
   #:support-function))

(in-package #:org.shirakumo.fraf.trial.mpr)

(defconstant COLLIDE-EPS 1f-3)

(defun search-point (a b +dir pa pb p)
  (let ((-dir (v- +dir)))
    (declare (dynamic-extent -dir))
    (org.shirakumo.fraf.trial.gjk::%support-function b +dir pb)
    (org.shirakumo.fraf.trial.gjk::%support-function a -dir pa)
    (!v- p pb pa)))

(defmacro with-vecs (vecs &body body)
  `(let ,(loop for vec in vecs collect `(,vec (vec3)))
     (declare (dynamic-extent ,@vecs))
     ,@body))

(defun %mpr (p1 p2 return-normal point1 point2)
  (flet ((finish (value)
           (return-from %mpr value)))
    (with-vecs (v01 v02 v0 v11 v12 v1 v21 v22 v2 v31 v32 v3 v41 v42 v4 n)
      (trial:global-location p1 v01)
      (trial:global-location p2 v02)
      (!v- v0 v02 v01)
      (when (v= 0 v0)
        (vsetf v0 0.00001 0 0))
      (!v- n v0)
      (search-point p1 p2 n v11 v12 v1)
      (when (<= (v. v1 n) 0)
        (finish NIL))
      (!vc n v1 v0)
      (when (v= 0 n)
        (!v- n v1 v0)
        (nvunit n)
        (v<- return-normal n)
        (v<- point1 v11)
        (v<- point2 v12)
        (finish T))
      (search-point p1 p2 n v21 v22 v2)
      (when (<= (v. v2 n) 0)
        (finish NIL))
      (!vc n (v- v1 v0) (v- v2 v0))
      (let ((dist (v. n v0)))
        (when (< 0 dist)
          (rotatef v1 v2)
          (rotatef v11 v21)
          (rotatef v12 v22)
          (nv- n)))

      (loop for hit = NIL
            do (search-point p1 p2 n v31 v32 v3)
               (when (<= (v. v3 n) 0)
                 (finish NIL))
               (cond ((< (v. (vc v1 v3) v0) 0)
                      (v<- v2 v3)
                      (v<- v21 v31)
                      (v<- v22 v32)
                      (!vc n (v- v1 v0) (v- v3 v0)))
                     ((< (v. (vc v3 v2) v0) 0)
                      (v<- v1 v3)
                      (v<- v11 v31)
                      (v<- v12 v32)
                      (!vc n (v- v3 v0) (v- v2 v0)))
                     (T
                      (loop (!vc n (v- v2 v1) (v- v3 v1))
                            (assert (not (v= 0 n)))
                            (nvunit n)
                            (let ((d (v. n v1)))
                              (when (and (not hit) (<= 0 d))
                                (v<- return-normal n)
                                (let* ((b0 (v. (vc v1 v2) v3))
                                       (b1 (v. (vc v3 v2) v0))
                                       (b2 (v. (vc v0 v1) v3))
                                       (b3 (v. (vc v2 v1) v0))
                                       (sum (+ b0 b1 b2 b3)))
                                  (when (<= sum 0)
                                    (setf b0 0
                                          b1 (v. (vc v2 v3) n)
                                          b2 (v. (vc v3 v1) n)
                                          b3 (v. (vc v1 v2) n)
                                          sum (+ b1 b2 b3)))
                                  (!v* point1 v01 b0)
                                  (nv+* point1 v11 b1)
                                  (nv+* point1 v21 b2)
                                  (nv+* point1 v31 b3)
                                  (!v* point2 v02 b0)
                                  (nv+* point2 v12 b1)
                                  (nv+* point2 v22 b2)
                                  (nv+* point2 v32 b3)
                                  (setf hit T))))
                            (search-point p1 p2 n v41 v42 v4)
                            (let ((delta (v. (v- v4 v3) n))
                                  (separation (- (v. v4 n))))
                              (when (or (<= delta COLLIDE-EPS) (<= 0 separation))
                                (v<- return-normal n)
                                (finish hit))
                              (let* ((d1 (v. (vc v4 v1) v0))
                                     (d2 (v. (vc v4 v2) v0))
                                     (d3 (v. (vc v4 v3) v0)))
                                (if (< d1 0)
                                    (cond ((< d2 0)
                                           (v<- v1 v4)
                                           (v<- v11 v41)
                                           (v<- v12 v42))
                                          (T
                                           (v<- v3 v4)
                                           (v<- v31 v41)
                                           (v<- v32 v42)))
                                    (cond ((< d3 0)
                                           (v<- v2 v4)
                                           (v<- v21 v41)
                                           (v<- v22 v42))
                                          (T
                                           (v<- v1 v4)
                                           (v<- v11 v41)
                                           (v<- v12 v42)))))))))))))

(defun detect-hits (a b hits start end)
  (declare (type trial:primitive a b))
  (declare (type (unsigned-byte 32) start end))
  (declare (type simple-vector hits))
  (declare (optimize speed))
  (when (<= end start)
    (return-from detect-hits start))
  (let* ((hit (aref hits start))
         (n (trial:hit-normal hit)) (p1 (vec3)) (p2 (vec3)))
    (declare (dynamic-extent p1 p2))
    (cond ((%mpr a b n p1 p2)
           (with-vecs (s1 s2 s)
             (search-point a b n s1 s2 s)
             (setf (trial:hit-depth hit) (vdistance s1 s2))
             (v<- (trial:hit-location hit) s1))
           (trial:finish-hit hit a b)
           (1+ start))
          (T
           start))))
